---
author: Sora Tonami
date: 2025/05/05
description: まずは手始めにエアシリンダーを動かしてみよう！
layout: default
modified: 2025/09/01
title: エアシリンダーを動かしてみよう \| ロボット制御入門 \| 制御講習
title-short: エアシリンダーを動かしてみよう
---

いよいよ前回までで作ったプロジェクトで開発していきます。\
今回はエアシリンダーを動かします。

## ファイル構造について

...とその前に、これから開発していく上でどこに何があるか知っておくと便利です。\
ファイル構造について軽く書いておきます。

![ファイル構造]

赤で囲った部分はCMake関連のファイルです。ライブラリを追加する時には触るかもしれませんが、基本こっちから触ることはありません。\
水色で囲った部分はマイコンがプログラムを起動するために必要なヤツです。これも放置。

重要なのはここからで、黄色・緑で囲った部分(特に後者)を主に触っていきます。

黄色の方、`Inc`はヘッダーファイルを入れておきます。(`Include`の略だろうけど一般的には`include`が使われるので何故`Inc`なのか謎)\
緑の方、`Src`はソースファイルを入れておきます。(`Source code`の略なんだけど一般的には小文字スタートの`src`が使われるのでなんとも)

ヘッダー・ソースの違いは[コラム:ヘッダーとソースの違い]を参照。

その他にもCubeMXでやった設定内容が入ったIOCファイル、ライブラリが入った`Drivers`ディレクトリがありますが、触ることはありません。

## エアシリンダーを動かそう！

いよいよ本題のエアシリンダーです。

![エアシリンダーと電磁弁の大まかな動作の流れ]

エアシリンダー(図中央)は電磁弁(図左・右)によって制御されます。\
電磁弁は赤で示した弁を電気で動かす事で、タンクの圧縮空気を送ったり、外に向かって開放したりします。\
制御は単純で、信号のON/OFFで弁を切り替えます。ダントツで一番楽です。

STM32のHAL環境においてGPIOから出力する時は`HAL_GPIO_WritePin`か`HAL_GPIO_TogglePin`を使います。\
`Write`というのは、信号のON/OFFを「ONという状態をピンに書き込む」「OFFという状態をピンに書き込む」と捉えているんですね。\
一方`Toggle`は読んで字の如くON/OFFを切り替えます。

引数は両者とも2つ目までは共通で「どのピンに出力するか」をまず渡してやります。\
`Write`の方だけONなのかOFFなのかを渡してやります。`Toggle`は中に持ってるんで要らんという事です。

例としてはこう。

```c
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);   // PA5(GPIOAの5番ピン)にSET(ON)
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); // PA5(同上)にRESET(OFF)
//                GPIO?  GPIO_PIN_?  GPIO_PIN_(RE)SET
HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);                // PA5(同上)をON/OFF切り替え
```

ON/OFFとはそのまま書かずそれぞれSET/RESETと言ってますね。\
これは内部的には「ONであるか」というフラグで見ているので、そこに1をセットすんのか(0で)リセットすんのか、という風に捉えてるわけですね。

ちなみに、CubeMXでピンに名前を付けることができますが、例えば今回のは何もしてなければ「LD2」と言うピンがあるはずなのでこれを例に取ると、

```c
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
//                ???_GPIO_Port  ???_Pin
```

のように書けます。便利。\
なおこのピンはNUCLEO-F446REの基板表面のLEDに繋がっていてデフォルトで出力モードとなってます。折角なのでコレ使います。

お手元の`main.c`を開いて下さい。そんで、`/* USER CODE BEGIN 3 */`の下にカーソルを移動して頂戴。\
(めんｄので以降は`/* USER CODE BEGIN なんとか */`と`/* USER CODE END なんとか */`の間は`USER CODE なんとか`って呼ぶっす)

```c
  // (略)

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while(1) {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    // ＞＞＞＞＞ こ↑こ↓ ＜＜＜＜＜
  }
  /* USER CODE END 3 */
}

// (略)
```

で、ここにON/OFFのコードをぶち込めばON/OFFしてくれるわけです。\
が、このままだともれなく秒間1億回弱ぐらいの速度でON/OFFされちゃいます。これでは、いけませんね。\
なので、ちゃんと待ってあげましょう。

STM32のHAL環境において待ってあげる時は`HAL_Delay`を使ってやります。

```c
HAL_Delay(1000);
//            ms
```

この例は1秒待ちます。組み込み開発では大体時間の基本単位がミリ秒な気がします。まぁ丁度いいし妥当。<sup>[要出典]</sup>

まぁ1秒でも良いんですが0.5秒の方が~~絵面が面白い~~なんとなく分かりやすそう<sup>[要検証]</sup>なので0.5秒でやります。\
要するに500ミリ秒ですね。

なので`USER CODE 3`の中身は、

```c
HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
HAL_Delay(500);
```

といった所でしょうかね。ON/OFFを明示的に行うなら、

```c
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
HAL_Delay(500);
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
HAL_Delay(500);
```

みたいに書けばよき。

## 基板にぶち込んでみよう！

プログラム出来たんで基板にぶち込みませう。

(TODO:実行ボタン押してる画像)

上にある実行ボタン(多分①とかになるはず)を押すと勝手にビルドした後、\
OpenOCDが起動して書き込みまでやってくれます。楽。

これだけ。

## 次回予告

今回はエアシリンダーを動かしました。ただのON/OFFという所で気付いたかもしれませんが、実は全く同じ方法でLEDも光らせたり出来ます。\
次回は足回りの肝、モーターを動かします。

[前へ](4)・[次へ](6)

[ロボット制御入門Topへ](..#%E3%83%AD%E3%83%9C%E3%83%83%E3%83%88%E5%88%B6%E5%BE%A1%E5%85%A5%E9%96%80)

[エアシリンダーと電磁弁の大まかな動作の流れ]: /assets/lessons/program/air-cylinder.png
[コラム:ヘッダーとソースの違い]: column-difference-headers-and-sources
[ファイル構造]: /assets/lessons/program/file-structure.png
